# test_case_pronin_team

<details>
<summary><b>ЗАДАНИЕ:</b></summary>

tbf

</details>

## Запуск

Для запуска рекомендованы команды "docker compose". Если ваша версия утилиты предполагает использование только команд формата "docker-compose" - учитите это при запуске проекта и замените во всех командах.

1. Клонировать репозиторий

    ```bash
    git clone <ссылка с git-hub>
    ```

2. Перейти в папку /test_case_pronin_team

    ```bash
    cd test_case_pronin_team/
    ```

3. Создать файл .env по образцу .env.example из репозитория.  
   **Для упрощения тестового запуска рабочий .env я оставил в репозитории. После сдачи тестового задания - файл будет удалён.**

4. Поднять контейнеры в режиме вывода логов в терминал

    ```bash
    docker compose up
    ```

    Или в фоновом режиме

    ```bash
    docker compose up -d
    ```

5. Админка доступна по адресу <http://127.0.0.1:8000/admin/>. Чтобы воспользоваться ей - необходимо создать суперпользователя локально, выполнив команду ниже и введя свои данные пользователя.

    ```bash
    docker compose exec backend python manage.py createsuperuser
    ```

6. Чтобы прекратить работу контейнеров воспользуйтесь командой

    ```bash
    docker compose down
    ```

    Если хотите прекратить работу контейнеров с удалением томов данных, то дополните команду флагом -v

    ```bash
    docker compose down -v
    ```

## Схема БД проекта

![DB](./readme_images/database.png)

## Available endpoints

1. Загрузка нового csv-файла для обработки

    ```text
    http://127.0.0.1:8000/api/v1/add-deals
    ```

    Предоставленный для тестирования файл разположен в директории /test_case_pronin_team/test_data  
    Тестирование отправки файла на ручку проводилось через Postman с помощью form-data формата для отправки тела запроса.

    ### Формат запроса

    ```json
    {
        "deals": some_file.csv
    }
    ```

    ### Возможные ответы

    ```json
    {
        "Status": "OK"
    }
    ```

    ```json
    {
        "Status": "error",
        "Desc": "description"
    }
    ```

2. Получение списка топ-5 покупателей со списком камней

    ```text
    http://127.0.0.1:8000/api/v1/get-top
    ```

    ### Пример ответа

    ```json
    {
        "response": [
            {
                "username": "resplendent",
                "spent_money": 451731,
                "gems": [
                    "Танзанит",
                    "Рубин",
                    "Сапфир"
                ]
            },
            {
                "username": "bellwether",
                "spent_money": 217794,
                "gems": [
                    "Петерсит",
                    "Сапфир"
                ]
            },
        ]
    }
    ```

## Комментарии к решению

1. Если в отправленном файле есть строки, которые имеют пустые значения в ключах - они будут пропущены при создании сделок. Вероятно стоит сообщать пользователю о том, что не все строки обработаны, но следуя ТЗ возвращаю ответ OK, если других ошибок не возникло.
2. Одинаковые сделки не дублируются в базу. Уникальной сделка считается по сочетанию всех полей из файла.
3. GET запрос возвращает в ответе только клиентов, у которых были расходы. Если в базе не хватает информации, чтобы выбрать топ-5 клиентов, будет возвращено максимально возможное количество клиентов, которые совершали покупки. Если в базе нет ни одной сделки - содержание списка по ключу response будет пустым даже при наличии пользователей в базе. Считаю это верным поведением ручки.
4. Для кэширования в проект добавлен контейнер с Redis. Допускаю, что для данной задачи это может быть избыточно, но хранение в оперативной памяти мне не кажется правильной реализацией.
5. Не предполагается редактирование данных через админку - только просмотр. При изменении данных в админке не инвалидируется кэш, поэтому ответ API может быть некорректным.

## Контакты

**telegram** [@Menshikov_AS](https://t.me/Menshikov_AS)  
**e-mail** <a.menshikov1989@gmail.com>
